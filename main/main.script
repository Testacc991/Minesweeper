Node = require "main.node"
data = require "main.data"
local columns = data.columns
local rows = data.rows

local function showallmines(self)
	for y=1,columns do
		for x=1,rows do
			local node = self.nodes[y][x]
			if node.type == "mine" then
				node.flagged = false
				node.state = true
			end
		end
	end
end

local function updateall(self)
	if self.gameover == false then
		for y=1,columns do
			for x=1,rows do
				self.flagged = self.nodes[y][x].flagged
				self.state = self.nodes[y][x].state
				self.id = self.nodes[y][x].spawned
				self.mines = self.nodes[y][x].minesaround
				self.type = self.nodes[y][x].type
				self.label_url = msg.url(nil, self.id, "count")
				self.sprite_url = msg.url(nil, self.id , "sprite")
				if self.state and self.type == "empty" and not self.flagged then
					if self.mines > 0 then
						msg.post(self.sprite_url, "play_animation", { id = hash("emptynode_open") })
						msg.post(self.label_url, "enable")
						label.set_text(self.label_url, self.mines)
					else
						msg.post(self.label_url, "disable")
						msg.post(self.sprite_url, "play_animation", { id = hash("emptynode_open") })
					end
				elseif self.state and self.type == "mine" and not self.flagged then
					msg.post(self.sprite_url, "play_animation", { id = hash("mine_open") })
					msg.post(self.label_url, "disable")
					self.gameover = true
				elseif not self.state and self.flagged then
					msg.post(self.sprite_url, "play_animation", { id = hash("praporec") })
					msg.post(self.label_url, "disable")
				elseif not self.state and not self.flagged then
					msg.post(self.sprite_url, "play_animation", { id = hash("hidenode") })
					msg.post(self.label_url, "disable")
				else
					msg.post(self.label_url, "disable")
				end
			end
		end
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	math.randomseed(os.time()*99999)
	self.gameover = false
	
	self.state = nil
	self.id = nil
	self.mines = nil
	self.type = nil
	self.label_url = nil
	self.sprite_url = nil
	self.nodes = {}
	for y = 1,columns do
		self.nodes[y] = {}
		for x = 1,rows do
			local pos = data.tile2world(vmath.vector3(x,y,0))
			local node = Node.new(pos)
			node.spawned = factory.create("go#nodefactory",pos,nil,nil,data.scale)
			local int = math.random(1,100)
			if int < data.hardness then
				node.type = "mine"
			elseif int > data.hardness then
				node.type = "empty"
			else
				node.type = "empty"
			end
			--node.type = "empty"
			self.nodes[y][x] = node
		end
	end
	mt = {__index = function(table, key)
		return "pass" end}
		self.nodes = setmetatable(self.nodes,mt)
	for y=1,columns do
		for x=1,rows do
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y+1][x-1])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y+1][x])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y+1][x+1])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y][x+1])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y-1][x+1])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y-1][x])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y-1][x-1])
			self.nodes[y][x]:add_adjacent_vertex(self.nodes[y][x-1])

			self.nodes[y][x]:add_straight_adjacent_vertex(self.nodes[y+1][x])
			self.nodes[y][x]:add_straight_adjacent_vertex(self.nodes[y][x+1])
			self.nodes[y][x]:add_straight_adjacent_vertex(self.nodes[y-1][x])
			self.nodes[y][x]:add_straight_adjacent_vertex(self.nodes[y][x-1])
		end
	end
	--showallmines(self)
	updateall(self)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end


function update(self, dt)
	
end

function fixed_update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.released then
		--print("lol")
		local pos = vmath.vector3(action.x,action.y,0)
		local touch = data.tile2world(data.world2tile(pos))
		for y=1,columns do
			for x=1,rows do 
				local node = self.nodes[y][x]
				if node.pos == touch and node.state == false and not node.flagged then
					node.state = true 
					node:show_straight_adjacent_vertex()
					if node.type == "mine" then
						showallmines(self)
						print("game_over")
					end
				elseif node.pos == touch and node.state == true and not node.flagged then
					node:show_adjacent_vertex()
				end
			end
		end
		updateall(self)		
	elseif action_id == hash("touch2") and action.released then
		local pos = vmath.vector3(action.x,action.y,0)
		local touch = data.tile2world(data.world2tile(pos))
		for y=1,columns do
			for x=1,rows do 
				local node = self.nodes[y][x]
				if node.pos == touch and node.state == false then
					if not node.flagged then
						node.flagged = true
					elseif node.flagged then
						node.flagged = false
					end
				end
			end
		end
		updateall(self)
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
